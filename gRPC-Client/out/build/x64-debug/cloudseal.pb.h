// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: cloudseal.proto
// Protobuf C++ Version: 5.29.3

#ifndef cloudseal_2eproto_2epb_2eh
#define cloudseal_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_cloudseal_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_cloudseal_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_cloudseal_2eproto;
namespace cloudseal {
class AuthRequest;
struct AuthRequestDefaultTypeInternal;
extern AuthRequestDefaultTypeInternal _AuthRequest_default_instance_;
class AuthResponse;
struct AuthResponseDefaultTypeInternal;
extern AuthResponseDefaultTypeInternal _AuthResponse_default_instance_;
class AuthToken;
struct AuthTokenDefaultTypeInternal;
extern AuthTokenDefaultTypeInternal _AuthToken_default_instance_;
class FileList;
struct FileListDefaultTypeInternal;
extern FileListDefaultTypeInternal _FileList_default_instance_;
class FileTransferPath;
struct FileTransferPathDefaultTypeInternal;
extern FileTransferPathDefaultTypeInternal _FileTransferPath_default_instance_;
class GlobalStats;
struct GlobalStatsDefaultTypeInternal;
extern GlobalStatsDefaultTypeInternal _GlobalStats_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class VaultQuery;
struct VaultQueryDefaultTypeInternal;
extern VaultQueryDefaultTypeInternal _VaultQuery_default_instance_;
class VaultRequest;
struct VaultRequestDefaultTypeInternal;
extern VaultRequestDefaultTypeInternal _VaultRequest_default_instance_;
class VaultResponse;
struct VaultResponseDefaultTypeInternal;
extern VaultResponseDefaultTypeInternal _VaultResponse_default_instance_;
}  // namespace cloudseal
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace cloudseal {

// ===================================================================


// -------------------------------------------------------------------

class VaultResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cloudseal.VaultResponse) */ {
 public:
  inline VaultResponse() : VaultResponse(nullptr) {}
  ~VaultResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VaultResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VaultResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VaultResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline VaultResponse(const VaultResponse& from) : VaultResponse(nullptr, from) {}
  inline VaultResponse(VaultResponse&& from) noexcept
      : VaultResponse(nullptr, std::move(from)) {}
  inline VaultResponse& operator=(const VaultResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VaultResponse& operator=(VaultResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VaultResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VaultResponse* internal_default_instance() {
    return reinterpret_cast<const VaultResponse*>(
        &_VaultResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(VaultResponse& a, VaultResponse& b) { a.Swap(&b); }
  inline void Swap(VaultResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VaultResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VaultResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VaultResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VaultResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VaultResponse& from) { VaultResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VaultResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cloudseal.VaultResponse"; }

 protected:
  explicit VaultResponse(::google::protobuf::Arena* arena);
  VaultResponse(::google::protobuf::Arena* arena, const VaultResponse& from);
  VaultResponse(::google::protobuf::Arena* arena, VaultResponse&& from) noexcept
      : VaultResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLocalPathFieldNumber = 1,
  };
  // string local_path = 1;
  void clear_local_path() ;
  const std::string& local_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_local_path(Arg_&& arg, Args_... args);
  std::string* mutable_local_path();
  PROTOBUF_NODISCARD std::string* release_local_path();
  void set_allocated_local_path(std::string* value);

  private:
  const std::string& _internal_local_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_path(
      const std::string& value);
  std::string* _internal_mutable_local_path();

  public:
  // @@protoc_insertion_point(class_scope:cloudseal.VaultResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      42, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VaultResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr local_path_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cloudseal_2eproto;
};
// -------------------------------------------------------------------

class VaultRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cloudseal.VaultRequest) */ {
 public:
  inline VaultRequest() : VaultRequest(nullptr) {}
  ~VaultRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VaultRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VaultRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VaultRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline VaultRequest(const VaultRequest& from) : VaultRequest(nullptr, from) {}
  inline VaultRequest(VaultRequest&& from) noexcept
      : VaultRequest(nullptr, std::move(from)) {}
  inline VaultRequest& operator=(const VaultRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VaultRequest& operator=(VaultRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VaultRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VaultRequest* internal_default_instance() {
    return reinterpret_cast<const VaultRequest*>(
        &_VaultRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(VaultRequest& a, VaultRequest& b) { a.Swap(&b); }
  inline void Swap(VaultRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VaultRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VaultRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VaultRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VaultRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VaultRequest& from) { VaultRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VaultRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cloudseal.VaultRequest"; }

 protected:
  explicit VaultRequest(::google::protobuf::Arena* arena);
  VaultRequest(::google::protobuf::Arena* arena, const VaultRequest& from);
  VaultRequest(::google::protobuf::Arena* arena, VaultRequest&& from) noexcept
      : VaultRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTokenFieldNumber = 1,
    kLocalPathFieldNumber = 2,
  };
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // string local_path = 2;
  void clear_local_path() ;
  const std::string& local_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_local_path(Arg_&& arg, Args_... args);
  std::string* mutable_local_path();
  PROTOBUF_NODISCARD std::string* release_local_path();
  void set_allocated_local_path(std::string* value);

  private:
  const std::string& _internal_local_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_path(
      const std::string& value);
  std::string* _internal_mutable_local_path();

  public:
  // @@protoc_insertion_point(class_scope:cloudseal.VaultRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      46, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VaultRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::google::protobuf::internal::ArenaStringPtr local_path_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cloudseal_2eproto;
};
// -------------------------------------------------------------------

class VaultQuery final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cloudseal.VaultQuery) */ {
 public:
  inline VaultQuery() : VaultQuery(nullptr) {}
  ~VaultQuery() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VaultQuery* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VaultQuery));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VaultQuery(
      ::google::protobuf::internal::ConstantInitialized);

  inline VaultQuery(const VaultQuery& from) : VaultQuery(nullptr, from) {}
  inline VaultQuery(VaultQuery&& from) noexcept
      : VaultQuery(nullptr, std::move(from)) {}
  inline VaultQuery& operator=(const VaultQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline VaultQuery& operator=(VaultQuery&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VaultQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const VaultQuery* internal_default_instance() {
    return reinterpret_cast<const VaultQuery*>(
        &_VaultQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(VaultQuery& a, VaultQuery& b) { a.Swap(&b); }
  inline void Swap(VaultQuery* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VaultQuery* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VaultQuery* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VaultQuery>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VaultQuery& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VaultQuery& from) { VaultQuery::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VaultQuery* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cloudseal.VaultQuery"; }

 protected:
  explicit VaultQuery(::google::protobuf::Arena* arena);
  VaultQuery(::google::protobuf::Arena* arena, const VaultQuery& from);
  VaultQuery(::google::protobuf::Arena* arena, VaultQuery&& from) noexcept
      : VaultQuery(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // @@protoc_insertion_point(class_scope:cloudseal.VaultQuery)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      34, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VaultQuery& from_msg);
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cloudseal_2eproto;
};
// -------------------------------------------------------------------

class Status final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cloudseal.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Status* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Status));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Status(
      ::google::protobuf::internal::ConstantInitialized);

  inline Status(const Status& from) : Status(nullptr, from) {}
  inline Status(Status&& from) noexcept
      : Status(nullptr, std::move(from)) {}
  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
        &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(Status& a, Status& b) { a.Swap(&b); }
  inline void Swap(Status* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Status>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Status& from) { Status::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Status* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cloudseal.Status"; }

 protected:
  explicit Status(::google::protobuf::Arena* arena);
  Status(::google::protobuf::Arena* arena, const Status& from);
  Status(::google::protobuf::Arena* arena, Status&& from) noexcept
      : Status(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cloudseal.Status)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      32, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Status& from_msg);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cloudseal_2eproto;
};
// -------------------------------------------------------------------

class GlobalStats final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cloudseal.GlobalStats) */ {
 public:
  inline GlobalStats() : GlobalStats(nullptr) {}
  ~GlobalStats() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GlobalStats* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GlobalStats));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GlobalStats(
      ::google::protobuf::internal::ConstantInitialized);

  inline GlobalStats(const GlobalStats& from) : GlobalStats(nullptr, from) {}
  inline GlobalStats(GlobalStats&& from) noexcept
      : GlobalStats(nullptr, std::move(from)) {}
  inline GlobalStats& operator=(const GlobalStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalStats& operator=(GlobalStats&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalStats* internal_default_instance() {
    return reinterpret_cast<const GlobalStats*>(
        &_GlobalStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(GlobalStats& a, GlobalStats& b) { a.Swap(&b); }
  inline void Swap(GlobalStats* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GlobalStats* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GlobalStats>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GlobalStats& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GlobalStats& from) { GlobalStats::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GlobalStats* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cloudseal.GlobalStats"; }

 protected:
  explicit GlobalStats(::google::protobuf::Arena* arena);
  GlobalStats(::google::protobuf::Arena* arena, const GlobalStats& from);
  GlobalStats(::google::protobuf::Arena* arena, GlobalStats&& from) noexcept
      : GlobalStats(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTotalFieldNumber = 1,
    kFreeFieldNumber = 2,
  };
  // int64 total = 1;
  void clear_total() ;
  ::int64_t total() const;
  void set_total(::int64_t value);

  private:
  ::int64_t _internal_total() const;
  void _internal_set_total(::int64_t value);

  public:
  // int64 free = 2;
  void clear_free() ;
  ::int64_t free() const;
  void set_free(::int64_t value);

  private:
  ::int64_t _internal_free() const;
  void _internal_set_free(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cloudseal.GlobalStats)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GlobalStats& from_msg);
    ::int64_t total_;
    ::int64_t free_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cloudseal_2eproto;
};
// -------------------------------------------------------------------

class FileTransferPath final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cloudseal.FileTransferPath) */ {
 public:
  inline FileTransferPath() : FileTransferPath(nullptr) {}
  ~FileTransferPath() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FileTransferPath* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FileTransferPath));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FileTransferPath(
      ::google::protobuf::internal::ConstantInitialized);

  inline FileTransferPath(const FileTransferPath& from) : FileTransferPath(nullptr, from) {}
  inline FileTransferPath(FileTransferPath&& from) noexcept
      : FileTransferPath(nullptr, std::move(from)) {}
  inline FileTransferPath& operator=(const FileTransferPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileTransferPath& operator=(FileTransferPath&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileTransferPath& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileTransferPath* internal_default_instance() {
    return reinterpret_cast<const FileTransferPath*>(
        &_FileTransferPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(FileTransferPath& a, FileTransferPath& b) { a.Swap(&b); }
  inline void Swap(FileTransferPath* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileTransferPath* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileTransferPath* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FileTransferPath>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FileTransferPath& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FileTransferPath& from) { FileTransferPath::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FileTransferPath* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cloudseal.FileTransferPath"; }

 protected:
  explicit FileTransferPath(::google::protobuf::Arena* arena);
  FileTransferPath(::google::protobuf::Arena* arena, const FileTransferPath& from);
  FileTransferPath(::google::protobuf::Arena* arena, FileTransferPath&& from) noexcept
      : FileTransferPath(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTokenFieldNumber = 1,
    kRemoteNameFieldNumber = 2,
    kLocalPathFieldNumber = 3,
  };
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // string remote_name = 2;
  void clear_remote_name() ;
  const std::string& remote_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_remote_name(Arg_&& arg, Args_... args);
  std::string* mutable_remote_name();
  PROTOBUF_NODISCARD std::string* release_remote_name();
  void set_allocated_remote_name(std::string* value);

  private:
  const std::string& _internal_remote_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_name(
      const std::string& value);
  std::string* _internal_mutable_remote_name();

  public:
  // string local_path = 3;
  void clear_local_path() ;
  const std::string& local_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_local_path(Arg_&& arg, Args_... args);
  std::string* mutable_local_path();
  PROTOBUF_NODISCARD std::string* release_local_path();
  void set_allocated_local_path(std::string* value);

  private:
  const std::string& _internal_local_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_path(
      const std::string& value);
  std::string* _internal_mutable_local_path();

  public:
  // @@protoc_insertion_point(class_scope:cloudseal.FileTransferPath)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      61, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FileTransferPath& from_msg);
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::google::protobuf::internal::ArenaStringPtr remote_name_;
    ::google::protobuf::internal::ArenaStringPtr local_path_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cloudseal_2eproto;
};
// -------------------------------------------------------------------

class FileList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cloudseal.FileList) */ {
 public:
  inline FileList() : FileList(nullptr) {}
  ~FileList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FileList* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FileList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FileList(
      ::google::protobuf::internal::ConstantInitialized);

  inline FileList(const FileList& from) : FileList(nullptr, from) {}
  inline FileList(FileList&& from) noexcept
      : FileList(nullptr, std::move(from)) {}
  inline FileList& operator=(const FileList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileList& operator=(FileList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileList& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileList* internal_default_instance() {
    return reinterpret_cast<const FileList*>(
        &_FileList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(FileList& a, FileList& b) { a.Swap(&b); }
  inline void Swap(FileList* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileList* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FileList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FileList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FileList& from) { FileList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FileList* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cloudseal.FileList"; }

 protected:
  explicit FileList(::google::protobuf::Arena* arena);
  FileList(::google::protobuf::Arena* arena, const FileList& from);
  FileList(::google::protobuf::Arena* arena, FileList&& from) noexcept
      : FileList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNamesFieldNumber = 1,
  };
  // repeated string names = 1;
  int names_size() const;
  private:
  int _internal_names_size() const;

  public:
  void clear_names() ;
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_names(int index, Arg_&& value, Args_... args);
  std::string* add_names();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_names(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_names();

  public:
  // @@protoc_insertion_point(class_scope:cloudseal.FileList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      32, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FileList& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> names_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cloudseal_2eproto;
};
// -------------------------------------------------------------------

class AuthToken final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cloudseal.AuthToken) */ {
 public:
  inline AuthToken() : AuthToken(nullptr) {}
  ~AuthToken() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AuthToken* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AuthToken));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AuthToken(
      ::google::protobuf::internal::ConstantInitialized);

  inline AuthToken(const AuthToken& from) : AuthToken(nullptr, from) {}
  inline AuthToken(AuthToken&& from) noexcept
      : AuthToken(nullptr, std::move(from)) {}
  inline AuthToken& operator=(const AuthToken& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthToken& operator=(AuthToken&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthToken& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthToken* internal_default_instance() {
    return reinterpret_cast<const AuthToken*>(
        &_AuthToken_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(AuthToken& a, AuthToken& b) { a.Swap(&b); }
  inline void Swap(AuthToken* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthToken* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthToken* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AuthToken>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AuthToken& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AuthToken& from) { AuthToken::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AuthToken* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cloudseal.AuthToken"; }

 protected:
  explicit AuthToken(::google::protobuf::Arena* arena);
  AuthToken(::google::protobuf::Arena* arena, const AuthToken& from);
  AuthToken(::google::protobuf::Arena* arena, AuthToken&& from) noexcept
      : AuthToken(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // @@protoc_insertion_point(class_scope:cloudseal.AuthToken)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      33, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AuthToken& from_msg);
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cloudseal_2eproto;
};
// -------------------------------------------------------------------

class AuthResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cloudseal.AuthResponse) */ {
 public:
  inline AuthResponse() : AuthResponse(nullptr) {}
  ~AuthResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AuthResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AuthResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AuthResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline AuthResponse(const AuthResponse& from) : AuthResponse(nullptr, from) {}
  inline AuthResponse(AuthResponse&& from) noexcept
      : AuthResponse(nullptr, std::move(from)) {}
  inline AuthResponse& operator=(const AuthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthResponse& operator=(AuthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthResponse* internal_default_instance() {
    return reinterpret_cast<const AuthResponse*>(
        &_AuthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(AuthResponse& a, AuthResponse& b) { a.Swap(&b); }
  inline void Swap(AuthResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AuthResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AuthResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AuthResponse& from) { AuthResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AuthResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cloudseal.AuthResponse"; }

 protected:
  explicit AuthResponse(::google::protobuf::Arena* arena);
  AuthResponse(::google::protobuf::Arena* arena, const AuthResponse& from);
  AuthResponse(::google::protobuf::Arena* arena, AuthResponse&& from) noexcept
      : AuthResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kTokenFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // string token = 3;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cloudseal.AuthResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      43, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AuthResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::internal::ArenaStringPtr token_;
    bool success_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cloudseal_2eproto;
};
// -------------------------------------------------------------------

class AuthRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cloudseal.AuthRequest) */ {
 public:
  inline AuthRequest() : AuthRequest(nullptr) {}
  ~AuthRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AuthRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AuthRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AuthRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline AuthRequest(const AuthRequest& from) : AuthRequest(nullptr, from) {}
  inline AuthRequest(AuthRequest&& from) noexcept
      : AuthRequest(nullptr, std::move(from)) {}
  inline AuthRequest& operator=(const AuthRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRequest& operator=(AuthRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRequest* internal_default_instance() {
    return reinterpret_cast<const AuthRequest*>(
        &_AuthRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(AuthRequest& a, AuthRequest& b) { a.Swap(&b); }
  inline void Swap(AuthRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AuthRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AuthRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AuthRequest& from) { AuthRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AuthRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cloudseal.AuthRequest"; }

 protected:
  explicit AuthRequest(::google::protobuf::Arena* arena);
  AuthRequest(::google::protobuf::Arena* arena, const AuthRequest& from);
  AuthRequest(::google::protobuf::Arena* arena, AuthRequest&& from) noexcept
      : AuthRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:cloudseal.AuthRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      46, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AuthRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cloudseal_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AuthRequest

// string username = 1;
inline void AuthRequest::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& AuthRequest::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cloudseal.AuthRequest.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthRequest::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cloudseal.AuthRequest.username)
}
inline std::string* AuthRequest::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:cloudseal.AuthRequest.username)
  return _s;
}
inline const std::string& AuthRequest::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void AuthRequest::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* AuthRequest::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* AuthRequest::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cloudseal.AuthRequest.username)
  return _impl_.username_.Release();
}
inline void AuthRequest::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cloudseal.AuthRequest.username)
}

// string password = 2;
inline void AuthRequest::clear_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& AuthRequest::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cloudseal.AuthRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cloudseal.AuthRequest.password)
}
inline std::string* AuthRequest::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:cloudseal.AuthRequest.password)
  return _s;
}
inline const std::string& AuthRequest::_internal_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_.Get();
}
inline void AuthRequest::_internal_set_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(value, GetArena());
}
inline std::string* AuthRequest::_internal_mutable_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* AuthRequest::release_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cloudseal.AuthRequest.password)
  return _impl_.password_.Release();
}
inline void AuthRequest::set_allocated_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cloudseal.AuthRequest.password)
}

// -------------------------------------------------------------------

// AuthResponse

// bool success = 1;
inline void AuthResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
}
inline bool AuthResponse::success() const {
  // @@protoc_insertion_point(field_get:cloudseal.AuthResponse.success)
  return _internal_success();
}
inline void AuthResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:cloudseal.AuthResponse.success)
}
inline bool AuthResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void AuthResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string message = 2;
inline void AuthResponse::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& AuthResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cloudseal.AuthResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cloudseal.AuthResponse.message)
}
inline std::string* AuthResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:cloudseal.AuthResponse.message)
  return _s;
}
inline const std::string& AuthResponse::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void AuthResponse::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* AuthResponse::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* AuthResponse::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cloudseal.AuthResponse.message)
  return _impl_.message_.Release();
}
inline void AuthResponse::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cloudseal.AuthResponse.message)
}

// string token = 3;
inline void AuthResponse::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& AuthResponse::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cloudseal.AuthResponse.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthResponse::set_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cloudseal.AuthResponse.token)
}
inline std::string* AuthResponse::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:cloudseal.AuthResponse.token)
  return _s;
}
inline const std::string& AuthResponse::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void AuthResponse::_internal_set_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(value, GetArena());
}
inline std::string* AuthResponse::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* AuthResponse::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cloudseal.AuthResponse.token)
  return _impl_.token_.Release();
}
inline void AuthResponse::set_allocated_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cloudseal.AuthResponse.token)
}

// -------------------------------------------------------------------

// AuthToken

// string token = 1;
inline void AuthToken::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& AuthToken::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cloudseal.AuthToken.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthToken::set_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cloudseal.AuthToken.token)
}
inline std::string* AuthToken::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:cloudseal.AuthToken.token)
  return _s;
}
inline const std::string& AuthToken::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void AuthToken::_internal_set_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(value, GetArena());
}
inline std::string* AuthToken::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* AuthToken::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cloudseal.AuthToken.token)
  return _impl_.token_.Release();
}
inline void AuthToken::set_allocated_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cloudseal.AuthToken.token)
}

// -------------------------------------------------------------------

// VaultRequest

// string token = 1;
inline void VaultRequest::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& VaultRequest::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cloudseal.VaultRequest.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VaultRequest::set_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cloudseal.VaultRequest.token)
}
inline std::string* VaultRequest::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:cloudseal.VaultRequest.token)
  return _s;
}
inline const std::string& VaultRequest::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void VaultRequest::_internal_set_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(value, GetArena());
}
inline std::string* VaultRequest::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* VaultRequest::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cloudseal.VaultRequest.token)
  return _impl_.token_.Release();
}
inline void VaultRequest::set_allocated_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cloudseal.VaultRequest.token)
}

// string local_path = 2;
inline void VaultRequest::clear_local_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_path_.ClearToEmpty();
}
inline const std::string& VaultRequest::local_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cloudseal.VaultRequest.local_path)
  return _internal_local_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VaultRequest::set_local_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cloudseal.VaultRequest.local_path)
}
inline std::string* VaultRequest::mutable_local_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_local_path();
  // @@protoc_insertion_point(field_mutable:cloudseal.VaultRequest.local_path)
  return _s;
}
inline const std::string& VaultRequest::_internal_local_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.local_path_.Get();
}
inline void VaultRequest::_internal_set_local_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_path_.Set(value, GetArena());
}
inline std::string* VaultRequest::_internal_mutable_local_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.local_path_.Mutable( GetArena());
}
inline std::string* VaultRequest::release_local_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cloudseal.VaultRequest.local_path)
  return _impl_.local_path_.Release();
}
inline void VaultRequest::set_allocated_local_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_path_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.local_path_.IsDefault()) {
    _impl_.local_path_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cloudseal.VaultRequest.local_path)
}

// -------------------------------------------------------------------

// VaultQuery

// string token = 1;
inline void VaultQuery::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& VaultQuery::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cloudseal.VaultQuery.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VaultQuery::set_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cloudseal.VaultQuery.token)
}
inline std::string* VaultQuery::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:cloudseal.VaultQuery.token)
  return _s;
}
inline const std::string& VaultQuery::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void VaultQuery::_internal_set_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(value, GetArena());
}
inline std::string* VaultQuery::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* VaultQuery::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cloudseal.VaultQuery.token)
  return _impl_.token_.Release();
}
inline void VaultQuery::set_allocated_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cloudseal.VaultQuery.token)
}

// -------------------------------------------------------------------

// VaultResponse

// string local_path = 1;
inline void VaultResponse::clear_local_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_path_.ClearToEmpty();
}
inline const std::string& VaultResponse::local_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cloudseal.VaultResponse.local_path)
  return _internal_local_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VaultResponse::set_local_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cloudseal.VaultResponse.local_path)
}
inline std::string* VaultResponse::mutable_local_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_local_path();
  // @@protoc_insertion_point(field_mutable:cloudseal.VaultResponse.local_path)
  return _s;
}
inline const std::string& VaultResponse::_internal_local_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.local_path_.Get();
}
inline void VaultResponse::_internal_set_local_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_path_.Set(value, GetArena());
}
inline std::string* VaultResponse::_internal_mutable_local_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.local_path_.Mutable( GetArena());
}
inline std::string* VaultResponse::release_local_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cloudseal.VaultResponse.local_path)
  return _impl_.local_path_.Release();
}
inline void VaultResponse::set_allocated_local_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_path_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.local_path_.IsDefault()) {
    _impl_.local_path_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cloudseal.VaultResponse.local_path)
}

// -------------------------------------------------------------------

// FileTransferPath

// string token = 1;
inline void FileTransferPath::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& FileTransferPath::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cloudseal.FileTransferPath.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FileTransferPath::set_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cloudseal.FileTransferPath.token)
}
inline std::string* FileTransferPath::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:cloudseal.FileTransferPath.token)
  return _s;
}
inline const std::string& FileTransferPath::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void FileTransferPath::_internal_set_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(value, GetArena());
}
inline std::string* FileTransferPath::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* FileTransferPath::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cloudseal.FileTransferPath.token)
  return _impl_.token_.Release();
}
inline void FileTransferPath::set_allocated_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cloudseal.FileTransferPath.token)
}

// string remote_name = 2;
inline void FileTransferPath::clear_remote_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_name_.ClearToEmpty();
}
inline const std::string& FileTransferPath::remote_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cloudseal.FileTransferPath.remote_name)
  return _internal_remote_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FileTransferPath::set_remote_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cloudseal.FileTransferPath.remote_name)
}
inline std::string* FileTransferPath::mutable_remote_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_remote_name();
  // @@protoc_insertion_point(field_mutable:cloudseal.FileTransferPath.remote_name)
  return _s;
}
inline const std::string& FileTransferPath::_internal_remote_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.remote_name_.Get();
}
inline void FileTransferPath::_internal_set_remote_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_name_.Set(value, GetArena());
}
inline std::string* FileTransferPath::_internal_mutable_remote_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.remote_name_.Mutable( GetArena());
}
inline std::string* FileTransferPath::release_remote_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cloudseal.FileTransferPath.remote_name)
  return _impl_.remote_name_.Release();
}
inline void FileTransferPath::set_allocated_remote_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.remote_name_.IsDefault()) {
    _impl_.remote_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cloudseal.FileTransferPath.remote_name)
}

// string local_path = 3;
inline void FileTransferPath::clear_local_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_path_.ClearToEmpty();
}
inline const std::string& FileTransferPath::local_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cloudseal.FileTransferPath.local_path)
  return _internal_local_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FileTransferPath::set_local_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cloudseal.FileTransferPath.local_path)
}
inline std::string* FileTransferPath::mutable_local_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_local_path();
  // @@protoc_insertion_point(field_mutable:cloudseal.FileTransferPath.local_path)
  return _s;
}
inline const std::string& FileTransferPath::_internal_local_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.local_path_.Get();
}
inline void FileTransferPath::_internal_set_local_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_path_.Set(value, GetArena());
}
inline std::string* FileTransferPath::_internal_mutable_local_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.local_path_.Mutable( GetArena());
}
inline std::string* FileTransferPath::release_local_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cloudseal.FileTransferPath.local_path)
  return _impl_.local_path_.Release();
}
inline void FileTransferPath::set_allocated_local_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_path_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.local_path_.IsDefault()) {
    _impl_.local_path_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cloudseal.FileTransferPath.local_path)
}

// -------------------------------------------------------------------

// FileList

// repeated string names = 1;
inline int FileList::_internal_names_size() const {
  return _internal_names().size();
}
inline int FileList::names_size() const {
  return _internal_names_size();
}
inline void FileList::clear_names() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.names_.Clear();
}
inline std::string* FileList::add_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:cloudseal.FileList.names)
  return _s;
}
inline const std::string& FileList::names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cloudseal.FileList.names)
  return _internal_names().Get(index);
}
inline std::string* FileList::mutable_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cloudseal.FileList.names)
  return _internal_mutable_names()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void FileList::set_names(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_names()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:cloudseal.FileList.names)
}
template <typename Arg_, typename... Args_>
inline void FileList::add_names(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_names(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:cloudseal.FileList.names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FileList::names() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cloudseal.FileList.names)
  return _internal_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
FileList::mutable_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cloudseal.FileList.names)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FileList::_internal_names() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
FileList::_internal_mutable_names() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.names_;
}

// -------------------------------------------------------------------

// GlobalStats

// int64 total = 1;
inline void GlobalStats::clear_total() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_ = ::int64_t{0};
}
inline ::int64_t GlobalStats::total() const {
  // @@protoc_insertion_point(field_get:cloudseal.GlobalStats.total)
  return _internal_total();
}
inline void GlobalStats::set_total(::int64_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:cloudseal.GlobalStats.total)
}
inline ::int64_t GlobalStats::_internal_total() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_;
}
inline void GlobalStats::_internal_set_total(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_ = value;
}

// int64 free = 2;
inline void GlobalStats::clear_free() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.free_ = ::int64_t{0};
}
inline ::int64_t GlobalStats::free() const {
  // @@protoc_insertion_point(field_get:cloudseal.GlobalStats.free)
  return _internal_free();
}
inline void GlobalStats::set_free(::int64_t value) {
  _internal_set_free(value);
  // @@protoc_insertion_point(field_set:cloudseal.GlobalStats.free)
}
inline ::int64_t GlobalStats::_internal_free() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.free_;
}
inline void GlobalStats::_internal_set_free(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.free_ = value;
}

// -------------------------------------------------------------------

// Status

// bool success = 1;
inline void Status::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
}
inline bool Status::success() const {
  // @@protoc_insertion_point(field_get:cloudseal.Status.success)
  return _internal_success();
}
inline void Status::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:cloudseal.Status.success)
}
inline bool Status::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void Status::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string message = 2;
inline void Status::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Status::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cloudseal.Status.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Status::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cloudseal.Status.message)
}
inline std::string* Status::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:cloudseal.Status.message)
  return _s;
}
inline const std::string& Status::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void Status::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* Status::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* Status::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cloudseal.Status.message)
  return _impl_.message_.Release();
}
inline void Status::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cloudseal.Status.message)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace cloudseal


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // cloudseal_2eproto_2epb_2eh
